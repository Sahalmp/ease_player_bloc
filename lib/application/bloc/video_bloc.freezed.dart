// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'video_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$VideoEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(FavouritesModel model) addfav,
    required TResult Function() getallFav,
    required TResult Function(int index) delfav,
    required TResult Function(HistoryModel model) addHistory,
    required TResult Function() getallHistory,
    required TResult Function(int index) delHistory,
    required TResult Function() clearHistory,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(Addfav value) addfav,
    required TResult Function(GetallFav value) getallFav,
    required TResult Function(Delfav value) delfav,
    required TResult Function(AddHistory value) addHistory,
    required TResult Function(GetallHistory value) getallHistory,
    required TResult Function(DelHistory value) delHistory,
    required TResult Function(ClearHistory value) clearHistory,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VideoEventCopyWith<$Res> {
  factory $VideoEventCopyWith(
          VideoEvent value, $Res Function(VideoEvent) then) =
      _$VideoEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$VideoEventCopyWithImpl<$Res> implements $VideoEventCopyWith<$Res> {
  _$VideoEventCopyWithImpl(this._value, this._then);

  final VideoEvent _value;
  // ignore: unused_field
  final $Res Function(VideoEvent) _then;
}

/// @nodoc
abstract class _$$InitializeCopyWith<$Res> {
  factory _$$InitializeCopyWith(
          _$Initialize value, $Res Function(_$Initialize) then) =
      __$$InitializeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitializeCopyWithImpl<$Res> extends _$VideoEventCopyWithImpl<$Res>
    implements _$$InitializeCopyWith<$Res> {
  __$$InitializeCopyWithImpl(
      _$Initialize _value, $Res Function(_$Initialize) _then)
      : super(_value, (v) => _then(v as _$Initialize));

  @override
  _$Initialize get _value => super._value as _$Initialize;
}

/// @nodoc

class _$Initialize with DiagnosticableTreeMixin implements Initialize {
  const _$Initialize();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VideoEvent.initialize()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'VideoEvent.initialize'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Initialize);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(FavouritesModel model) addfav,
    required TResult Function() getallFav,
    required TResult Function(int index) delfav,
    required TResult Function(HistoryModel model) addHistory,
    required TResult Function() getallHistory,
    required TResult Function(int index) delHistory,
    required TResult Function() clearHistory,
  }) {
    return initialize();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
  }) {
    return initialize?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
    required TResult orElse(),
  }) {
    if (initialize != null) {
      return initialize();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(Addfav value) addfav,
    required TResult Function(GetallFav value) getallFav,
    required TResult Function(Delfav value) delfav,
    required TResult Function(AddHistory value) addHistory,
    required TResult Function(GetallHistory value) getallHistory,
    required TResult Function(DelHistory value) delHistory,
    required TResult Function(ClearHistory value) clearHistory,
  }) {
    return initialize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
  }) {
    return initialize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
    required TResult orElse(),
  }) {
    if (initialize != null) {
      return initialize(this);
    }
    return orElse();
  }
}

abstract class Initialize implements VideoEvent {
  const factory Initialize() = _$Initialize;
}

/// @nodoc
abstract class _$$AddfavCopyWith<$Res> {
  factory _$$AddfavCopyWith(_$Addfav value, $Res Function(_$Addfav) then) =
      __$$AddfavCopyWithImpl<$Res>;
  $Res call({FavouritesModel model});
}

/// @nodoc
class __$$AddfavCopyWithImpl<$Res> extends _$VideoEventCopyWithImpl<$Res>
    implements _$$AddfavCopyWith<$Res> {
  __$$AddfavCopyWithImpl(_$Addfav _value, $Res Function(_$Addfav) _then)
      : super(_value, (v) => _then(v as _$Addfav));

  @override
  _$Addfav get _value => super._value as _$Addfav;

  @override
  $Res call({
    Object? model = freezed,
  }) {
    return _then(_$Addfav(
      model: model == freezed
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as FavouritesModel,
    ));
  }
}

/// @nodoc

class _$Addfav with DiagnosticableTreeMixin implements Addfav {
  const _$Addfav({required this.model});

  @override
  final FavouritesModel model;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VideoEvent.addfav(model: $model)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'VideoEvent.addfav'))
      ..add(DiagnosticsProperty('model', model));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Addfav &&
            const DeepCollectionEquality().equals(other.model, model));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(model));

  @JsonKey(ignore: true)
  @override
  _$$AddfavCopyWith<_$Addfav> get copyWith =>
      __$$AddfavCopyWithImpl<_$Addfav>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(FavouritesModel model) addfav,
    required TResult Function() getallFav,
    required TResult Function(int index) delfav,
    required TResult Function(HistoryModel model) addHistory,
    required TResult Function() getallHistory,
    required TResult Function(int index) delHistory,
    required TResult Function() clearHistory,
  }) {
    return addfav(model);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
  }) {
    return addfav?.call(model);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
    required TResult orElse(),
  }) {
    if (addfav != null) {
      return addfav(model);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(Addfav value) addfav,
    required TResult Function(GetallFav value) getallFav,
    required TResult Function(Delfav value) delfav,
    required TResult Function(AddHistory value) addHistory,
    required TResult Function(GetallHistory value) getallHistory,
    required TResult Function(DelHistory value) delHistory,
    required TResult Function(ClearHistory value) clearHistory,
  }) {
    return addfav(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
  }) {
    return addfav?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
    required TResult orElse(),
  }) {
    if (addfav != null) {
      return addfav(this);
    }
    return orElse();
  }
}

abstract class Addfav implements VideoEvent {
  const factory Addfav({required final FavouritesModel model}) = _$Addfav;

  FavouritesModel get model => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$AddfavCopyWith<_$Addfav> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetallFavCopyWith<$Res> {
  factory _$$GetallFavCopyWith(
          _$GetallFav value, $Res Function(_$GetallFav) then) =
      __$$GetallFavCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetallFavCopyWithImpl<$Res> extends _$VideoEventCopyWithImpl<$Res>
    implements _$$GetallFavCopyWith<$Res> {
  __$$GetallFavCopyWithImpl(
      _$GetallFav _value, $Res Function(_$GetallFav) _then)
      : super(_value, (v) => _then(v as _$GetallFav));

  @override
  _$GetallFav get _value => super._value as _$GetallFav;
}

/// @nodoc

class _$GetallFav with DiagnosticableTreeMixin implements GetallFav {
  const _$GetallFav();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VideoEvent.getallFav()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'VideoEvent.getallFav'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetallFav);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(FavouritesModel model) addfav,
    required TResult Function() getallFav,
    required TResult Function(int index) delfav,
    required TResult Function(HistoryModel model) addHistory,
    required TResult Function() getallHistory,
    required TResult Function(int index) delHistory,
    required TResult Function() clearHistory,
  }) {
    return getallFav();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
  }) {
    return getallFav?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
    required TResult orElse(),
  }) {
    if (getallFav != null) {
      return getallFav();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(Addfav value) addfav,
    required TResult Function(GetallFav value) getallFav,
    required TResult Function(Delfav value) delfav,
    required TResult Function(AddHistory value) addHistory,
    required TResult Function(GetallHistory value) getallHistory,
    required TResult Function(DelHistory value) delHistory,
    required TResult Function(ClearHistory value) clearHistory,
  }) {
    return getallFav(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
  }) {
    return getallFav?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
    required TResult orElse(),
  }) {
    if (getallFav != null) {
      return getallFav(this);
    }
    return orElse();
  }
}

abstract class GetallFav implements VideoEvent {
  const factory GetallFav() = _$GetallFav;
}

/// @nodoc
abstract class _$$DelfavCopyWith<$Res> {
  factory _$$DelfavCopyWith(_$Delfav value, $Res Function(_$Delfav) then) =
      __$$DelfavCopyWithImpl<$Res>;
  $Res call({int index});
}

/// @nodoc
class __$$DelfavCopyWithImpl<$Res> extends _$VideoEventCopyWithImpl<$Res>
    implements _$$DelfavCopyWith<$Res> {
  __$$DelfavCopyWithImpl(_$Delfav _value, $Res Function(_$Delfav) _then)
      : super(_value, (v) => _then(v as _$Delfav));

  @override
  _$Delfav get _value => super._value as _$Delfav;

  @override
  $Res call({
    Object? index = freezed,
  }) {
    return _then(_$Delfav(
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Delfav with DiagnosticableTreeMixin implements Delfav {
  const _$Delfav({required this.index});

  @override
  final int index;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VideoEvent.delfav(index: $index)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'VideoEvent.delfav'))
      ..add(DiagnosticsProperty('index', index));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Delfav &&
            const DeepCollectionEquality().equals(other.index, index));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(index));

  @JsonKey(ignore: true)
  @override
  _$$DelfavCopyWith<_$Delfav> get copyWith =>
      __$$DelfavCopyWithImpl<_$Delfav>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(FavouritesModel model) addfav,
    required TResult Function() getallFav,
    required TResult Function(int index) delfav,
    required TResult Function(HistoryModel model) addHistory,
    required TResult Function() getallHistory,
    required TResult Function(int index) delHistory,
    required TResult Function() clearHistory,
  }) {
    return delfav(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
  }) {
    return delfav?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
    required TResult orElse(),
  }) {
    if (delfav != null) {
      return delfav(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(Addfav value) addfav,
    required TResult Function(GetallFav value) getallFav,
    required TResult Function(Delfav value) delfav,
    required TResult Function(AddHistory value) addHistory,
    required TResult Function(GetallHistory value) getallHistory,
    required TResult Function(DelHistory value) delHistory,
    required TResult Function(ClearHistory value) clearHistory,
  }) {
    return delfav(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
  }) {
    return delfav?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
    required TResult orElse(),
  }) {
    if (delfav != null) {
      return delfav(this);
    }
    return orElse();
  }
}

abstract class Delfav implements VideoEvent {
  const factory Delfav({required final int index}) = _$Delfav;

  int get index => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$DelfavCopyWith<_$Delfav> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddHistoryCopyWith<$Res> {
  factory _$$AddHistoryCopyWith(
          _$AddHistory value, $Res Function(_$AddHistory) then) =
      __$$AddHistoryCopyWithImpl<$Res>;
  $Res call({HistoryModel model});
}

/// @nodoc
class __$$AddHistoryCopyWithImpl<$Res> extends _$VideoEventCopyWithImpl<$Res>
    implements _$$AddHistoryCopyWith<$Res> {
  __$$AddHistoryCopyWithImpl(
      _$AddHistory _value, $Res Function(_$AddHistory) _then)
      : super(_value, (v) => _then(v as _$AddHistory));

  @override
  _$AddHistory get _value => super._value as _$AddHistory;

  @override
  $Res call({
    Object? model = freezed,
  }) {
    return _then(_$AddHistory(
      model: model == freezed
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as HistoryModel,
    ));
  }
}

/// @nodoc

class _$AddHistory with DiagnosticableTreeMixin implements AddHistory {
  const _$AddHistory({required this.model});

  @override
  final HistoryModel model;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VideoEvent.addHistory(model: $model)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'VideoEvent.addHistory'))
      ..add(DiagnosticsProperty('model', model));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddHistory &&
            const DeepCollectionEquality().equals(other.model, model));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(model));

  @JsonKey(ignore: true)
  @override
  _$$AddHistoryCopyWith<_$AddHistory> get copyWith =>
      __$$AddHistoryCopyWithImpl<_$AddHistory>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(FavouritesModel model) addfav,
    required TResult Function() getallFav,
    required TResult Function(int index) delfav,
    required TResult Function(HistoryModel model) addHistory,
    required TResult Function() getallHistory,
    required TResult Function(int index) delHistory,
    required TResult Function() clearHistory,
  }) {
    return addHistory(model);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
  }) {
    return addHistory?.call(model);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
    required TResult orElse(),
  }) {
    if (addHistory != null) {
      return addHistory(model);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(Addfav value) addfav,
    required TResult Function(GetallFav value) getallFav,
    required TResult Function(Delfav value) delfav,
    required TResult Function(AddHistory value) addHistory,
    required TResult Function(GetallHistory value) getallHistory,
    required TResult Function(DelHistory value) delHistory,
    required TResult Function(ClearHistory value) clearHistory,
  }) {
    return addHistory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
  }) {
    return addHistory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
    required TResult orElse(),
  }) {
    if (addHistory != null) {
      return addHistory(this);
    }
    return orElse();
  }
}

abstract class AddHistory implements VideoEvent {
  const factory AddHistory({required final HistoryModel model}) = _$AddHistory;

  HistoryModel get model => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$AddHistoryCopyWith<_$AddHistory> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetallHistoryCopyWith<$Res> {
  factory _$$GetallHistoryCopyWith(
          _$GetallHistory value, $Res Function(_$GetallHistory) then) =
      __$$GetallHistoryCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetallHistoryCopyWithImpl<$Res> extends _$VideoEventCopyWithImpl<$Res>
    implements _$$GetallHistoryCopyWith<$Res> {
  __$$GetallHistoryCopyWithImpl(
      _$GetallHistory _value, $Res Function(_$GetallHistory) _then)
      : super(_value, (v) => _then(v as _$GetallHistory));

  @override
  _$GetallHistory get _value => super._value as _$GetallHistory;
}

/// @nodoc

class _$GetallHistory with DiagnosticableTreeMixin implements GetallHistory {
  const _$GetallHistory();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VideoEvent.getallHistory()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'VideoEvent.getallHistory'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetallHistory);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(FavouritesModel model) addfav,
    required TResult Function() getallFav,
    required TResult Function(int index) delfav,
    required TResult Function(HistoryModel model) addHistory,
    required TResult Function() getallHistory,
    required TResult Function(int index) delHistory,
    required TResult Function() clearHistory,
  }) {
    return getallHistory();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
  }) {
    return getallHistory?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
    required TResult orElse(),
  }) {
    if (getallHistory != null) {
      return getallHistory();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(Addfav value) addfav,
    required TResult Function(GetallFav value) getallFav,
    required TResult Function(Delfav value) delfav,
    required TResult Function(AddHistory value) addHistory,
    required TResult Function(GetallHistory value) getallHistory,
    required TResult Function(DelHistory value) delHistory,
    required TResult Function(ClearHistory value) clearHistory,
  }) {
    return getallHistory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
  }) {
    return getallHistory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
    required TResult orElse(),
  }) {
    if (getallHistory != null) {
      return getallHistory(this);
    }
    return orElse();
  }
}

abstract class GetallHistory implements VideoEvent {
  const factory GetallHistory() = _$GetallHistory;
}

/// @nodoc
abstract class _$$DelHistoryCopyWith<$Res> {
  factory _$$DelHistoryCopyWith(
          _$DelHistory value, $Res Function(_$DelHistory) then) =
      __$$DelHistoryCopyWithImpl<$Res>;
  $Res call({int index});
}

/// @nodoc
class __$$DelHistoryCopyWithImpl<$Res> extends _$VideoEventCopyWithImpl<$Res>
    implements _$$DelHistoryCopyWith<$Res> {
  __$$DelHistoryCopyWithImpl(
      _$DelHistory _value, $Res Function(_$DelHistory) _then)
      : super(_value, (v) => _then(v as _$DelHistory));

  @override
  _$DelHistory get _value => super._value as _$DelHistory;

  @override
  $Res call({
    Object? index = freezed,
  }) {
    return _then(_$DelHistory(
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$DelHistory with DiagnosticableTreeMixin implements DelHistory {
  const _$DelHistory({required this.index});

  @override
  final int index;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VideoEvent.delHistory(index: $index)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'VideoEvent.delHistory'))
      ..add(DiagnosticsProperty('index', index));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DelHistory &&
            const DeepCollectionEquality().equals(other.index, index));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(index));

  @JsonKey(ignore: true)
  @override
  _$$DelHistoryCopyWith<_$DelHistory> get copyWith =>
      __$$DelHistoryCopyWithImpl<_$DelHistory>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(FavouritesModel model) addfav,
    required TResult Function() getallFav,
    required TResult Function(int index) delfav,
    required TResult Function(HistoryModel model) addHistory,
    required TResult Function() getallHistory,
    required TResult Function(int index) delHistory,
    required TResult Function() clearHistory,
  }) {
    return delHistory(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
  }) {
    return delHistory?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
    required TResult orElse(),
  }) {
    if (delHistory != null) {
      return delHistory(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(Addfav value) addfav,
    required TResult Function(GetallFav value) getallFav,
    required TResult Function(Delfav value) delfav,
    required TResult Function(AddHistory value) addHistory,
    required TResult Function(GetallHistory value) getallHistory,
    required TResult Function(DelHistory value) delHistory,
    required TResult Function(ClearHistory value) clearHistory,
  }) {
    return delHistory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
  }) {
    return delHistory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
    required TResult orElse(),
  }) {
    if (delHistory != null) {
      return delHistory(this);
    }
    return orElse();
  }
}

abstract class DelHistory implements VideoEvent {
  const factory DelHistory({required final int index}) = _$DelHistory;

  int get index => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$DelHistoryCopyWith<_$DelHistory> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ClearHistoryCopyWith<$Res> {
  factory _$$ClearHistoryCopyWith(
          _$ClearHistory value, $Res Function(_$ClearHistory) then) =
      __$$ClearHistoryCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClearHistoryCopyWithImpl<$Res> extends _$VideoEventCopyWithImpl<$Res>
    implements _$$ClearHistoryCopyWith<$Res> {
  __$$ClearHistoryCopyWithImpl(
      _$ClearHistory _value, $Res Function(_$ClearHistory) _then)
      : super(_value, (v) => _then(v as _$ClearHistory));

  @override
  _$ClearHistory get _value => super._value as _$ClearHistory;
}

/// @nodoc

class _$ClearHistory with DiagnosticableTreeMixin implements ClearHistory {
  const _$ClearHistory();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VideoEvent.clearHistory()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'VideoEvent.clearHistory'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ClearHistory);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(FavouritesModel model) addfav,
    required TResult Function() getallFav,
    required TResult Function(int index) delfav,
    required TResult Function(HistoryModel model) addHistory,
    required TResult Function() getallHistory,
    required TResult Function(int index) delHistory,
    required TResult Function() clearHistory,
  }) {
    return clearHistory();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
  }) {
    return clearHistory?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(FavouritesModel model)? addfav,
    TResult Function()? getallFav,
    TResult Function(int index)? delfav,
    TResult Function(HistoryModel model)? addHistory,
    TResult Function()? getallHistory,
    TResult Function(int index)? delHistory,
    TResult Function()? clearHistory,
    required TResult orElse(),
  }) {
    if (clearHistory != null) {
      return clearHistory();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(Addfav value) addfav,
    required TResult Function(GetallFav value) getallFav,
    required TResult Function(Delfav value) delfav,
    required TResult Function(AddHistory value) addHistory,
    required TResult Function(GetallHistory value) getallHistory,
    required TResult Function(DelHistory value) delHistory,
    required TResult Function(ClearHistory value) clearHistory,
  }) {
    return clearHistory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
  }) {
    return clearHistory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(Addfav value)? addfav,
    TResult Function(GetallFav value)? getallFav,
    TResult Function(Delfav value)? delfav,
    TResult Function(AddHistory value)? addHistory,
    TResult Function(GetallHistory value)? getallHistory,
    TResult Function(DelHistory value)? delHistory,
    TResult Function(ClearHistory value)? clearHistory,
    required TResult orElse(),
  }) {
    if (clearHistory != null) {
      return clearHistory(this);
    }
    return orElse();
  }
}

abstract class ClearHistory implements VideoEvent {
  const factory ClearHistory() = _$ClearHistory;
}

/// @nodoc
mixin _$VideoState {
  List<FavouritesModel> get favouritesList =>
      throw _privateConstructorUsedError;
  List<HistoryModel> get historyList => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $VideoStateCopyWith<VideoState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VideoStateCopyWith<$Res> {
  factory $VideoStateCopyWith(
          VideoState value, $Res Function(VideoState) then) =
      _$VideoStateCopyWithImpl<$Res>;
  $Res call(
      {List<FavouritesModel> favouritesList, List<HistoryModel> historyList});
}

/// @nodoc
class _$VideoStateCopyWithImpl<$Res> implements $VideoStateCopyWith<$Res> {
  _$VideoStateCopyWithImpl(this._value, this._then);

  final VideoState _value;
  // ignore: unused_field
  final $Res Function(VideoState) _then;

  @override
  $Res call({
    Object? favouritesList = freezed,
    Object? historyList = freezed,
  }) {
    return _then(_value.copyWith(
      favouritesList: favouritesList == freezed
          ? _value.favouritesList
          : favouritesList // ignore: cast_nullable_to_non_nullable
              as List<FavouritesModel>,
      historyList: historyList == freezed
          ? _value.historyList
          : historyList // ignore: cast_nullable_to_non_nullable
              as List<HistoryModel>,
    ));
  }
}

/// @nodoc
abstract class _$$_VideoStateCopyWith<$Res>
    implements $VideoStateCopyWith<$Res> {
  factory _$$_VideoStateCopyWith(
          _$_VideoState value, $Res Function(_$_VideoState) then) =
      __$$_VideoStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<FavouritesModel> favouritesList, List<HistoryModel> historyList});
}

/// @nodoc
class __$$_VideoStateCopyWithImpl<$Res> extends _$VideoStateCopyWithImpl<$Res>
    implements _$$_VideoStateCopyWith<$Res> {
  __$$_VideoStateCopyWithImpl(
      _$_VideoState _value, $Res Function(_$_VideoState) _then)
      : super(_value, (v) => _then(v as _$_VideoState));

  @override
  _$_VideoState get _value => super._value as _$_VideoState;

  @override
  $Res call({
    Object? favouritesList = freezed,
    Object? historyList = freezed,
  }) {
    return _then(_$_VideoState(
      favouritesList: favouritesList == freezed
          ? _value._favouritesList
          : favouritesList // ignore: cast_nullable_to_non_nullable
              as List<FavouritesModel>,
      historyList: historyList == freezed
          ? _value._historyList
          : historyList // ignore: cast_nullable_to_non_nullable
              as List<HistoryModel>,
    ));
  }
}

/// @nodoc

class _$_VideoState with DiagnosticableTreeMixin implements _VideoState {
  const _$_VideoState(
      {required final List<FavouritesModel> favouritesList,
      required final List<HistoryModel> historyList})
      : _favouritesList = favouritesList,
        _historyList = historyList;

  final List<FavouritesModel> _favouritesList;
  @override
  List<FavouritesModel> get favouritesList {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_favouritesList);
  }

  final List<HistoryModel> _historyList;
  @override
  List<HistoryModel> get historyList {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_historyList);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'VideoState(favouritesList: $favouritesList, historyList: $historyList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'VideoState'))
      ..add(DiagnosticsProperty('favouritesList', favouritesList))
      ..add(DiagnosticsProperty('historyList', historyList));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_VideoState &&
            const DeepCollectionEquality()
                .equals(other._favouritesList, _favouritesList) &&
            const DeepCollectionEquality()
                .equals(other._historyList, _historyList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_favouritesList),
      const DeepCollectionEquality().hash(_historyList));

  @JsonKey(ignore: true)
  @override
  _$$_VideoStateCopyWith<_$_VideoState> get copyWith =>
      __$$_VideoStateCopyWithImpl<_$_VideoState>(this, _$identity);
}

abstract class _VideoState implements VideoState {
  const factory _VideoState(
      {required final List<FavouritesModel> favouritesList,
      required final List<HistoryModel> historyList}) = _$_VideoState;

  @override
  List<FavouritesModel> get favouritesList =>
      throw _privateConstructorUsedError;
  @override
  List<HistoryModel> get historyList => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_VideoStateCopyWith<_$_VideoState> get copyWith =>
      throw _privateConstructorUsedError;
}
